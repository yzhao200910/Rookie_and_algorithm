# 算法技巧总结

### 最大值问题，最小值问题：比如一个有重复元素组成的数组或者字符串，重复次数最多的

这种，可以用队列去维护这个最大值，把最大值维护在队列顶端 ，一般配合std::unorder_map<pair>计数

可以用STL容器，也可以自己手写。

## 第K个最大/或最小值：比如给你一个数组，让你求牌子第k大的元素是什么

当然还可以用快速选择

这种典型的堆问题，也是和上面队列的思想一样，只是他可以维护多个最大值（降序）或者最小值（升序）

写法： priority_queue<int ,vector<int>,greater<int>> heap;//小顶堆。维护前几个最大值，因为小的值会上浮，就很好把小的pop出，第k大的值会出现在堆顶。

priority_queue<int, vector<int>, less<int>> maxHeap;这个是大顶堆，维护小的值，大的值会上浮，所以很好的pop。

### 链表实现当中，统一操作

使用哨兵指针，可以统一操作

### 螺旋矩阵问题：

一层while 加四个for 循环

### 旋转数组问题：

二分法解决，不管他怎么旋转，肯定有一边是有序的





## 关于哈希表的使用

第一种情况;一个数出现最多次数的情况，利用unordered_mapd对每一种出现情况计数，为啥用这个呢，应为底层是红黑树实现，搜索速度快

第二种情况;利用哈希表去重问题，利用map，为啥map或者set是有count这个函数，可以统计一个数出现的次数，拿来去判断插入东西时是否在这之前有相似的出现。

第三种;将一个数映射到属于他自己应该在的位置，对一个很大的质数取余即可（减少哈希冲突问题）。
