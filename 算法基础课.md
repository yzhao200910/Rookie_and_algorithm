# 算法基础课数据结构篇

## Trie树（字典树）

基本用法：1：快速高效存储，查找字符串的集合的数据结构

![image-20231010201653732](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231010201653732.png)

存储一个单词后，都要在结尾打标记

代码思路：

```c++
const int N =100010;
/**
trie树那里，觉得可以稍微补充下怎么用数组去建树，一开始以为[N][26]的第一维度是树的层数；现在搞懂了，一维是结点总数，而结点和结点之间的关系（谁是谁儿子）存在第二个维度，比如[0][1]=3, [0]表示根节点，[1]表示它有一个儿子‘b’,这个儿子的下标是3；接着如果有一个[3][2]=8 ; 说明根节点的儿子‘b’也有一个儿子‘c’，这个孙子的下标就是8；这样传递下去，就是一个字符串。随便给一个结点][x][y], 并不能看出它在第几层，只能知道，它的儿子是谁。【菜鸡互助
**/

int son[N][26], cnt[N], idx;

class tree_ {
public:
    void insert(char str[]) {//插入字符，也就是创建字典树的过程
        int p = 0;
        for (int i = 0; str[i]; i++) {
            int u = str[i] - 'a';//哈希映射，每个字符对应编码的数字是不同的
            //用字符去减a就是对a的偏移量
            if (!son[p][u]) son[p][u] = ++idx;//
            p = son[p][u]; //
        }
        cnt[p]++;//对结尾进行标记
    }
    int query(char str[]){ //查找字符串
        int p=0;
        for (int i = 0; str[i]; i++) {
         int u=str[i] -'a';//第一次循环的情况：得到是否有第一个字母存在
         if(!son[p][u]) return 0;//没找到
         p=son[p][u];

​        }
​        return cnt[p];
​    }
};
```

```c++
class Trie {

public:

  /** Initialize your data structure here. */

  Trie() {

​    // 初始化数据结构

​    son = vector<vector<int>>(26, vector<int>(26, 0));

​    cnt = vector<int>(26, 0);

​    idx = 0;

  }

  

  /** Inserts a word into the trie. */

  void insert(string word) {

​    int p = 0;

​    for (int i = 0; i < word.size(); i++) {

​      int u = word[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        son[p][u] = ++idx;

​      }

​      p = son[p][u];

​    }

​    cnt[p]++;

  }

  

  /** Returns if the word is in the trie. */

  bool search(string word) {

​    int p = 0;

​    for (int i = 0; i < word.size(); i++) {

​      int u = word[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        return false;

​      }

​      p = son[p][u];

​    }

​    if (cnt[p]) {

​      return true;

​    } else {

​      return false;

​    }

  }

  

  /** Returns if there is any word in the trie that starts with the given prefix. */

  bool startsWith(string prefix) {

​    int p = 0;

​    for (int i = 0; i < prefix.size(); i++) {

​      int u = prefix[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        return false;

​      }

​      p = son[p][u];

​    }

​    return true;

  }

private:

  vector<vector<int>> son; // son[p][u] 表示第 p 个节点的第 u 个儿子节点的编号

  vector<int> cnt; // cnt[p] 表示第 p 个节点对应的单词数

  int idx;

};
```

```c++
class Trie {
private:
    struct TrieNode //26叉树结构体，结构体中包含它自己，即每一个子树又是一个26叉树
    {
        bool isWord;
        vector<shared_ptr<TrieNode>> children;
        TrieNode():isWord(false), children(26, nullptr){}   //成员列表初始化
    };

    shared_ptr<TrieNode> findPrefix(string& prefix)         //查找前缀的方法
    {
        auto node = root;
        for (int i = 0; i < prefix.length() && node != nullptr; ++ i)
        {
            node = node->children[prefix[i] - 'a'];
        }
        return node;            //若是前缀就返回最后一个字母所在的node，否则返回nullptr
    }
    
    shared_ptr<TrieNode> root;  

public:
    Trie() {
        root = make_shared<TrieNode>();     //初始化智能指针
    }
    

    //往前缀树中插入单词
    void insert(string word) {
        auto node = root;           //node为当前节点，从头节开始
        for (auto &ch : word)       //遍历每个字母，若字母对应的节点不存在，则创建它
        {
            if (node->children[ch - 'a'] == nullptr)
            {
                node->children[ch - 'a'] = make_shared<TrieNode>();
            }
    
            node = node->children[ch - 'a'];    //进入到对应的子树节点中，开始下一轮插入
        }
    
        node->isWord = true;        //整个单词遍历完后，将最后一个节点标记为单词结尾
    }
    
    //前缀树中查找单词
    bool search(string word) {
        auto node = findPrefix(word);
        return node != nullptr && node->isWord == true;
    }
    
    //前缀树中查找前缀
    bool startsWith(string prefix) {
        return findPrefix(prefix) != nullptr;
    }

};
```

参考leetcode作者

## 并查集

1：将两个集合合并

2：询问两个元素是否在一个集合当中

以上问题利用并查集可以做到O(1)的时间复杂度

<img src="C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231010220433015.png" alt="image-20231010220433015" style="zoom:50%;" />基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储他的父节点，p[x]表示x的父节点

问题1:如何判断树根 p[x]==x //p[x]为根节点也就是元素的编号

问题2：如何求x的集合编号：while(p[x]!=x) x=p[x]

问题三;如何合并集合：px是X的标号，py是y的集合编号。p[x]=y,将一个树变为另一个数的子树

优化 路径压缩

如果找到x的根节点是元素的编号，将他的所有子节点都指向元素的编号(也就是根节点)

image-20231010224113975

```c++
#include<iostream>

using namespace std;

const int N=100010;
int p[N];//定义多个集合

int find(int x)
{
    if(p[x]!=x) p[x]=find(p[x]);
    /*
    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:
    p[x]=x;
    */
    return p[x];
    //找到了便返回祖宗节点的值
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) p[i]=i;
    while(m--)
    {
        char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(*op=='M') p[find(a)]=find(b);//集合合并操作
        else
        if(find(a)==find(b))
        //如果祖宗节点一样,就输出yes
        printf("Yes\n");
        else
        printf("No\n");
    }
    return 0;
}
```

核心：把find函数理解即可

## 堆：手写堆

两个基本操作 down向下调整 up向上调整

功能：插入一个数：heap[++size]=x; up(size)

求集合当中最小的值  heap[1]

删除最小值。 heap[1]=heap[size]; size--;down(1)

( 技巧，因为是由一维数组去存储的，删除头节点难度太大，那么将最后的去代替最小的，然后减少数组的大小，再让替代的down即可 )

 删除任意元素：heap[k]=heap[size]; size--;down() or up()

修改任意元素:heap[k]=x,down() or up()

堆的结构：一个完全二叉树  

以小顶堆为列

存储：一维数组存储 如图：

![image-20231011213325044](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231011213325044.png)

## 哈希表

![image-20231012202620923](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231012202620923.png)

解决哈希冲突：

![image-20231012203805805](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231012203805805.png)

设计哈希表; 拉链法

`cons`

```c++
const int N = 19997;

class MyHashSet {
public:
    vector<int> h[N];//每一个h[i]看做一行

    /** Initialize your data structure here. */
    MyHashSet() {

    }

    int find(vector<int>& h, int key) {
        for (int i = 0; i < h.size(); i ++ )
            if (h[i] == key)
                return i;
        return -1;
    }

    void add(int key) {
        int t = key % N;
        int k = find(h[t], key);
        if (k == -1) h[t].push_back(key);//当前坑位处插入
    }

    void remove(int key) {
        int t = key % N;
        int k = find(h[t], key);
        if (k != -1) h[t].erase(h[t].begin() + k);//直接删除即可
    }

    /** Returns true if this set contains the specified element */
    bool contains(int key) {
        int t = key % N;
        int k = find(h[t], key);
        return k != -1;
    }
};

```

字符串哈希：

















## STL使用技巧 ：vector,string 不说

![image-20231013220058675](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013220058675.png)

![image-20231013221358185](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013221358185.png)



![image-20231013222728846](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013222728846.png)

# 搜索与图论

## DFS深度优先搜索与BFS宽度优先搜索

![image-20231013232152197](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013232152197.png)

## DFS（暴搜）：回溯和剪枝

最重要的是顺序（树结构）

以全排列这个题为列

![image-20231013233813970](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013233813970.png)







![image-20231013233853692](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013233853692.png)



```c++
### BFS：

class Solution {

public:

  vector<vector<int>> ans;

  vector<bool> st;//下标状态

  vector<int> path;



  vector<vector<int>> permute(vector<int>& nums) {



   st = vector<bool> (nums.size());

​    dfs(nums, 0);

​    return ans;

  }



  void dfs(vector<int> &nums, int u)

  {

​    if (u == nums.size())//下标等于数组长度，代表一种结果已就绪

​    {

​      ans.push_back(path);//将其插入到结果数组中

​      return ;

​    }



​    for (int i = 0; i < nums.size(); i ++ )

​      if (!st[i])

​      {

​        st[i] = true;

​        path.push_back(nums[i]);

​        dfs(nums, u + 1);

​        st[i] = false;//保持上一层的状态

​        path.pop_back();//保持上一层的状态

​      }

  }

};
```

```c++
相比较普通全排列，多了一步去重，利用哈希表去重

全排列||

`class Solution {`

`public:`

`vector<bool> st;`

`vector<int> path;`

`vector<vector<int>> re;`

`map<vector<int>,int>p;`

  `vector<vector<int>> permuteUnique(vector<int>& nums) {`

​     `st=vector<bool>(nums.size());`



​     `dfs(nums,0);`



​     `return re;` 

  `}`

   `void dfs(vector<int> &nums,int u){`

​    `if(u==nums.size()){`

​      `if(p.count(path)==0){`

​      `re.push_back(path);`

​      `p[path]++;`

​      `}`

​      `return ;`

​    `}`

​    `for(int i=0;i<nums.size();i++){`

​      `if(!st[i]){`

​        `st[i]=true;`

​        `path.push_back(nums[i]);`

​        `dfs(nums,u+1);`

​         `st[i]=false;`

​        `path.pop_back();`

​      `}`

​    `}`

  `}`

``  

`};`


```

怎样去理解回溯

![image-20231014065445830](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231014065445830.png)

N皇后问题:bfs

![image-20231014160510182](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231014160510182.png)

```c++
class Solution {

public:

int n;

vector<bool> col,dg,udg;//对不能出现的位置进行标记

vector<vector<string>> re;

vector<string> path;

  vector<vector<string>> solveNQueens(int _n) {

​      n=_n;

​      col=vector<bool>(n);

​      dg=udg=vector<bool>(n*2);

​      path=vector<string>(n,string(n,'.'));



​      dfs(0);



​      return re;

  }

  void dfs(int u){

​    if(u==n){//u==n,代表这条路可以走通，并且有有效的的值

​      re.push_back(path);

​      return; 

​    }

​    for(int i=0;i<n;i++){

​      if(!col[i]&&!dg[u-i+n]&&!udg[u+i]){

​        col[i]=dg[u-i+n]=udg[u+i]=true;

​        path[u][i]='Q';

​        dfs(u+1);

​        //回溯

​        path[u][i]='.';

​        col[i]=dg[u-i+n]=udg[u+i]=false;

​      }

​    }

  }

};
```

