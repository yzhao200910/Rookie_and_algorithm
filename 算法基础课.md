# 算法基础课篇

## Trie树（字典树）

基本用法：1：快速高效存储，查找字符串的集合的数据结构

![image-20231010201653732](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231010201653732.png)

存储一个单词后，都要在结尾打标记

代码思路：

```c++
const int N =100010;
/**
trie树那里，觉得可以稍微补充下怎么用数组去建树，一开始以为[N][26]的第一维度是树的层数；现在搞懂了，一维是结点总数，而结点和结点之间的关系（谁是谁儿子）存在第二个维度，比如[0][1]=3, [0]表示根节点，[1]表示它有一个儿子‘b’,这个儿子的下标是3；接着如果有一个[3][2]=8 ; 说明根节点的儿子‘b’也有一个儿子‘c’，这个孙子的下标就是8；这样传递下去，就是一个字符串。随便给一个结点][x][y], 并不能看出它在第几层，只能知道，它的儿子是谁。【菜鸡互助
**/

int son[N][26], cnt[N], idx;

class tree_ {
public:
    void insert(char str[]) {//插入字符，也就是创建字典树的过程
        int p = 0;
        for (int i = 0; str[i]; i++) {
            int u = str[i] - 'a';//哈希映射，每个字符对应编码的数字是不同的
            //用字符去减a就是对a的偏移量
            if (!son[p][u]) son[p][u] = ++idx;//
            p = son[p][u]; //
        }
        cnt[p]++;//对结尾进行标记
    }
    int query(char str[]){ //查找字符串
        int p=0;
        for (int i = 0; str[i]; i++) {
         int u=str[i] -'a';//第一次循环的情况：得到是否有第一个字母存在
         if(!son[p][u]) return 0;//没找到
         p=son[p][u];

​        }
​        return cnt[p];
​    }
};
```

```c++
class Trie {

public:

  /** Initialize your data structure here. */

  Trie() {

​    // 初始化数据结构

​    son = vector<vector<int>>(26, vector<int>(26, 0));

​    cnt = vector<int>(26, 0);

​    idx = 0;

  }

  

  /** Inserts a word into the trie. */

  void insert(string word) {

​    int p = 0;

​    for (int i = 0; i < word.size(); i++) {

​      int u = word[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        son[p][u] = ++idx;

​      }

​      p = son[p][u];

​    }

​    cnt[p]++;

  }

  

  /** Returns if the word is in the trie. */

  bool search(string word) {

​    int p = 0;

​    for (int i = 0; i < word.size(); i++) {

​      int u = word[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        return false;

​      }

​      p = son[p][u];

​    }

​    if (cnt[p]) {

​      return true;

​    } else {

​      return false;

​    }

  }

  

  /** Returns if there is any word in the trie that starts with the given prefix. */

  bool startsWith(string prefix) {

​    int p = 0;

​    for (int i = 0; i < prefix.size(); i++) {

​      int u = prefix[i] - 'a'; // 获取字母的映射位置

​      if (!son[p][u]) {

​        return false;

​      }

​      p = son[p][u];

​    }

​    return true;

  }

private:

  vector<vector<int>> son; // son[p][u] 表示第 p 个节点的第 u 个儿子节点的编号

  vector<int> cnt; // cnt[p] 表示第 p 个节点对应的单词数

  int idx;

};
```

```c++
class Trie {
private:
    struct TrieNode //26叉树结构体，结构体中包含它自己，即每一个子树又是一个26叉树
    {
        bool isWord;
        vector<shared_ptr<TrieNode>> children;
        TrieNode():isWord(false), children(26, nullptr){}   //成员列表初始化
    };

    shared_ptr<TrieNode> findPrefix(string& prefix)         //查找前缀的方法
    {
        auto node = root;
        for (int i = 0; i < prefix.length() && node != nullptr; ++ i)
        {
            node = node->children[prefix[i] - 'a'];
        }
        return node;            //若是前缀就返回最后一个字母所在的node，否则返回nullptr
    }
    
    shared_ptr<TrieNode> root;  

public:
    Trie() {
        root = make_shared<TrieNode>();     //初始化智能指针
    }
    

    //往前缀树中插入单词
    void insert(string word) {
        auto node = root;           //node为当前节点，从头节开始
        for (auto &ch : word)       //遍历每个字母，若字母对应的节点不存在，则创建它
        {
            if (node->children[ch - 'a'] == nullptr)
            {
                node->children[ch - 'a'] = make_shared<TrieNode>();
            }
    
            node = node->children[ch - 'a'];    //进入到对应的子树节点中，开始下一轮插入
        }
    
        node->isWord = true;        //整个单词遍历完后，将最后一个节点标记为单词结尾
    }
    
    //前缀树中查找单词
    bool search(string word) {
        auto node = findPrefix(word);
        return node != nullptr && node->isWord == true;
    }
    
    //前缀树中查找前缀
    bool startsWith(string prefix) {
        return findPrefix(prefix) != nullptr;
    }

};
```

参考leetcode作者

## 并查集

1：将两个集合合并

2：询问两个元素是否在一个集合当中

以上问题利用并查集可以做到O(1)的时间复杂度

<img src="C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231010220433015.png" alt="image-20231010220433015" style="zoom:50%;" />基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储他的父节点，p[x]表示x的父节点

问题1:如何判断树根 p[x]==x //p[x]为根节点也就是元素的编号

问题2：如何求x的集合编号：while(p[x]!=x) x=p[x]

问题三;如何合并集合：px是X的标号，py是y的集合编号。p[x]=y,将一个树变为另一个数的子树

优化 路径压缩

如果找到x的根节点是元素的编号，将他的所有子节点都指向元素的编号(也就是根节点)

image-20231010224113975

```c++
#include<iostream>

using namespace std;

const int N=100010;
int p[N];//定义多个集合

int find(int x)
{
    if(p[x]!=x) p[x]=find(p[x]);
    /*
    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:
    p[x]=x;
    */
    return p[x];
    //找到了便返回祖宗节点的值
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) p[i]=i;
    while(m--)
    {
        char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(*op=='M') p[find(a)]=find(b);//集合合并操作
        else
        if(find(a)==find(b))
        //如果祖宗节点一样,就输出yes
        printf("Yes\n");
        else
        printf("No\n");
    }
    return 0;
}
```

核心：把find函数理解即可

## 堆：手写堆

两个基本操作 down向下调整 up向上调整

功能：插入一个数：heap[++size]=x; up(size)

求集合当中最小的值  heap[1]

删除最小值。 heap[1]=heap[size]; size--;down(1)

( 技巧，因为是由一维数组去存储的，删除头节点难度太大，那么将最后的去代替最小的，然后减少数组的大小，再让替代的down即可 )

 删除任意元素：heap[k]=heap[size]; size--;down() or up()

修改任意元素:heap[k]=x,down() or up()

堆的结构：一个完全二叉树  

以小顶堆为列

存储：一维数组存储 如图：

![image-20231011213325044](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231011213325044.png)

## 哈希表

![image-20231012202620923](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231012202620923.png)

解决哈希冲突：

![image-20231012203805805](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231012203805805.png)

设计哈希表; 拉链法

`cons`

```c++
const int N = 19997;

class MyHashSet {
public:
    vector<int> h[N];//每一个h[i]看做一行

    /** Initialize your data structure here. */
    MyHashSet() {

    }

    int find(vector<int>& h, int key) {
        for (int i = 0; i < h.size(); i ++ )
            if (h[i] == key)
                return i;
        return -1;
    }

    void add(int key) {
        int t = key % N;
        int k = find(h[t], key);
        if (k == -1) h[t].push_back(key);//当前坑位处插入
    }

    void remove(int key) {
        int t = key % N;
        int k = find(h[t], key);
        if (k != -1) h[t].erase(h[t].begin() + k);//直接删除即可
    }

    /** Returns true if this set contains the specified element */
    bool contains(int key) {
        int t = key % N;
        int k = find(h[t], key);
        return k != -1;
    }
};

```

字符串哈希：

















## STL使用技巧 ：vector,string 不说

![image-20231013220058675](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013220058675.png)

![image-20231013221358185](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013221358185.png)



![image-20231013222728846](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013222728846.png)

## 数组篇：

![img](file:///C:\Users\16537\AppData\Local\Temp\ksohtml5936\wps1.jpg)



### 双指针

常见题：验证回文，判断子序列，盛最多水的容器，三数之和

双指针常见有两种：

一种是两个指针操作一个数组，一个是两个指针分别操作两个

两个指针摆放的位置也有考究，双指针不仅可以处理数组，字符串等，还可以操作链表（比如返回链表倒数第k的元素）



## 链表：

### 1：LRU缓存

双向链表



## 搜索与图论

### DFS深度优先搜索与BFS宽度优先搜索

![image-20231013232152197](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013232152197.png)

### DFS（暴搜）：回溯和剪枝

最重要的是顺序（树结构）

以全排列这个题为列

![image-20231013233813970](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013233813970.png)







![image-20231013233853692](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231013233853692.png)



```c++
### dFS：

class Solution {

public:

  vector<vector<int>> ans;

  vector<bool> st;//下标状态

  vector<int> path;



  vector<vector<int>> permute(vector<int>& nums) {



   st = vector<bool> (nums.size());

​    dfs(nums, 0);

​    return ans;

  }



  void dfs(vector<int> &nums, int u)

  {

​    if (u == nums.size())//下标等于数组长度，代表一种结果已就绪

​    {

​      ans.push_back(path);//将其插入到结果数组中

​      return ;

​    }



​    for (int i = 0; i < nums.size(); i ++ )

​      if (!st[i])

​      {

​        st[i] = true;

​        path.push_back(nums[i]);

​        dfs(nums, u + 1);

​        st[i] = false;//保持上一层的状态

​        path.pop_back();//保持上一层的状态

​      }

  }

};
```

```c++
相比较普通全排列，多了一步去重，利用哈希表去重

全排列||

`class Solution {`

`public:`

`vector<bool> st;`

`vector<int> path;`

`vector<vector<int>> re;`

`map<vector<int>,int>p;`

  `vector<vector<int>> permuteUnique(vector<int>& nums) {`

​     `st=vector<bool>(nums.size());`



​     `dfs(nums,0);`



​     `return re;` 

  `}`

   `void dfs(vector<int> &nums,int u){`

​    `if(u==nums.size()){`

​      `if(p.count(path)==0){`

​      `re.push_back(path);`

​      `p[path]++;`

​      `}`

​      `return ;`

​    `}`

​    `for(int i=0;i<nums.size();i++){`

​      `if(!st[i]){`

​        `st[i]=true;`

​        `path.push_back(nums[i]);`

​        `dfs(nums,u+1);`

​         `st[i]=false;`

​        `path.pop_back();`

​      `}`

​    `}`

  `}`

``  

`};`


```

怎样去理解回溯

![image-20231014065445830](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231014065445830.png)

N皇后问题:bfs

![image-20231014160510182](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231014160510182.png)

```c++
class Solution {

public:

int n;

vector<bool> col,dg,udg;//对不能出现的位置进行标记

vector<vector<string>> re;

vector<string> path;

  vector<vector<string>> solveNQueens(int _n) {

​      n=_n;

​      col=vector<bool>(n);

​      dg=udg=vector<bool>(n*2);

​      path=vector<string>(n,string(n,'.'));



​      dfs(0);



​      return re;

  }

  void dfs(int u){

​    if(u==n){//u==n,代表这条路可以走通，并且有有效的的值

​      re.push_back(path);

​      return; 

​    }

​    for(int i=0;i<n;i++){

​      if(!col[i]&&!dg[u-i+n]&&!udg[u+i]){

​        col[i]=dg[u-i+n]=udg[u+i]=true;

​        path[u][i]='Q';

​        dfs(u+1);

​        //回溯

​        path[u][i]='.';

​        col[i]=dg[u-i+n]=udg[u+i]=false;

​      }

​    }

  }

};
```

 我现在遇到最多的用dfs去解决的问题无非就两种排列和组合

这两种情况写代码是有技巧的

首先排列下的模板

```c++
//组合，是讲究无序的，只要组合元素相同他们也是一样的
//那么他的dfs怎么写呢
void dfs(int n,vector<int>&nums,int start){
    if()//递归终止条件
     if()//同上
    for(int i=start;i<nums.size();i++){
        if(!st[i]){
            //上锁
            //插入
            dfs(n+1;nums,i+1)
            //回溯
        }
    }
}
排列的代码
    void dfs(int n,vector<int>&nums){
    if()//递归终止条件
     if()//同上
    for(int i=0;i<nums.size();i++){
        if(!st[i]){
            //上锁
            //插入
            dfs(n+1;nums)
            //回溯
        }
    }
}
```





DFS关于分割问题：Leetcode 131分割回文串

解题思路：判断回文（双指针（这里不用对字符串进行处理）），通过深搜去分割



### BFS宽度优先搜索

以走迷宫这道题为列

![image-20231019001738543](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231019001738543.png)

上面画的数字是离起点的位置 

宽搜的基本框架：

![image-20231019002814981](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231019002814981.png)

理解最基本的bfs：二叉树的层序遍历

给出二叉树层序遍历的

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {//每一次while代表着二叉树的一层
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();//记入当前节点信息
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

![image-20231026230144714](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231026230144714.png)



## 图

### 有向图

有向图：边是有方向如;A->B，无向图：如A-B，一般建立A->B和A<-B 可以看成特殊的有向图

### 有向图的存储：

**1:邻接矩阵** 空间复杂度很高，n^n的空间复杂度

**2：邻接表：**就像单链表，有多少个点，就开了多少个单链表，里面的次序是无关的

![image-20231031185133874](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231031185133874.png)



### ![image-20231031185555182](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231031185555182.png)

### 图的遍历：深度与广度

**深搜**

![image-20231031190924760](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231031190924760.png)



```c++
//树与图的深搜
vector<bool> st;//查看这个点有没有被遍历过
void dfs（int n）{//任意挑一个点开始搜
    st[u]=true;//标记一下，遍历过就不用遍历
    for(int i=数组中第一个链表头;i!=空链表;i=下一个存放边的的链表){
        int j=当前点能到地方的一个点
            if(!st[j]) dfs(j);//继续向下搜
    }
}
```

图的一道例题

![image-20231031210709898](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231031210709898.png)

```c++
/**
flood fill算法
如果四条边中出现O，那么肯定是不被包围的，那么从这边界O出发，向四个方向去扩展遇到x那么就是被包围的
[["X","O","X","O","O","O"],["O","X","O","X","O","X"],["X","O","X","O","X","O"],["O","X","O","X","O","X"]]这种O的旁边还有O那么他也算，因为Dfs是可以标记到的
**/

class Solution {

private:

vector<vector<bool>>st;

int n,m;

int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};//上下左右移动

public:

  void solve(vector<vector<char>>& board) {

​    //初始化图，标记为每个点都未遍历

​    if(board.empty())return;

​    n=board.size(),m=board[0].size();

​    for(int i=0;i<n;i++){

​      vector<bool>temp;

​      for(int j=0;j<m;j++) temp.push_back(false);

​      st.push_back(temp);

​    }



​    for(int i=0;i<n;i++){

​      if(board[i][0]=='O')dfs(i,0,board);

​      if(board[i][m-1]=='O')dfs(i,m-1,board);

​    }

​    for(int i=0;i<m;i++){

​      if(board[0][i]=='O')dfs(0,i,board);

​      if(board[n-1][i]=='O')dfs(n-1,i,board);

​    }

​    for(int i=0;i<n;i++){

​      for(int j=0;j<m;j++){

​        if(!st[i][j]) board[i][j]='X';

​      }

​    }



  }

  void dfs(int x,int y,vector<vector<char>>&board){

​    st[x][y]=true;//在前面只有当前字母为O才能进入函数，也就是对为O的进行标记

​    for(int i=0;i<4;i++){

​      int a=x+dx[i],b=y+dy[i];

​      if(a>=0&&a<n&&b>=0&&b<m&&!st[a][b]&&board[a][b]=='O')

​        dfs(a,b,board);

​    }

  }

};
```

有向图：拓扑序列

有向无环图又被称为拓扑图，一个无环的有向图，至少有一个入度为0的点

![image-20231101200014699](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231101200014699.png)

例题：leetcode207课程表：

![image-20231101220353078](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231101220353078.png)

```c++
class Solution {

public:

  bool canFinish(int n, vector<vector<int>>& pre) {

   vector<vector<int>> g (n);

   vector<int> d(n);//记入入度点

   for(auto &e:pre){

​     int a=e[0],b=e[1];

​     g[a].push_back(b);

​     d[b]++;

   }



   queue<int> q;

   for(int i=0;i<n;i++)

​     if(d[i]==0) q.push(i);

​    int count=0;

   while(q.size()){

​     auto t=q.front();

​     q.pop();

​     count++;

​     for(auto i:g[t])

​       if(--d[i]==0)

​        q.push(i);

   }

   return n==count;

  }

};
```

### 最短路问题：只考虑有向图

源点：起点， 汇点：重点

![image-20231102203704822](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231102203704822.png)

##### Dijkstra算法

![image-20231102205443932](C:\Users\16537\AppData\Roaming\Typora\typora-user-images\image-20231102205443932.png)

第一步：初始化距离，一开始只有1号点是已知，其他不知道那么将未知距离设置为无穷

第二步:确定一个到起点的最短路（未知点中到原点距离最小的点），这是一个迭代的过程

Dijkstra算法处理有向权重图时，权重必须为正，而另外两种可以处理负权重有向图，但是不能出现负环，所谓负环，就是权值总和均为负的环。Dijkstra算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止，是一种广度优先的搜索方法。来自acwing hasp大佬的总结

```c++
//稠密图：邻接矩阵
//代码例子

int n,m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra(){
    
    memst(dist,0x3f,sizeof(dist))
    dist[1]=0;
    for(int i=0;i<n;i++){
        int t=-1;
        for(int j=1;j<=n;j++)
            if(!st[j]&&(t==-1||dist[t]>dist[j]))
                t=j
        st[t]=true;
        for(int j=1;j<=n;j++)
            dist[j]=min(dist[j],dist[t]+g[t][j]);
    }
    if(dist[n]==0x3f3f3f3f)  return -1;
    return dist[n];
}
int main(){
    //enter n,m
    memset(g,0x3f,sizeof(g))
    
        while(m--){
            int a,b,c;
            //enter a,b,c
            g[a][b]=min(g[a][b],c);
        }
    int t=dijkstra;
    printf("%d\n",t)
    return 0;
    
}

```





##### Bellman-ford算法









##### SPFA算法

例题：leetcode743：网络延迟

```c++
const int N = 110, M = 6010, INF = 0x3f3f3f3f;

//邻接表，这是一个稀疏图

int h[N], e[M], w[M], ne[M], idx;

int dist[N];

bool st[N];



class Solution {

public:

//添加

  void add(int a, int b, int c) {

​    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;

  }



  void spfa(int start) {

​    queue<int> q;

​    q.push(start);

​    memset(dist, 0x3f, sizeof dist);

​    dist[start] = 0;

​    while (q.size()) {

​      int t = q.front();

​      q.pop();

​      st[t] = false;

​      for (int i = h[t]; ~i; i = ne[i]) {

​        int j = e[i];

​        if (dist[j] > dist[t] + w[i]) {

​          dist[j] = dist[t] + w[i];

​          if (!st[j]) {

​            q.push(j);

​            st[j] = true;

​          }

​        }

​      }

​    }

  }



  int networkDelayTime(vector<vector<int>>& times, int n, int k) {

​    memset(h, -1, sizeof h);

​    idx = 0;

​    for (auto& e: times) {

​      int a = e[0], b = e[1], c = e[2];

​      add(a, b, c);

​    }

​    spfa(k);

​    int res = 1;

​    for (int i = 1; i <= n; i ++ ) res = max(res, dist[i]);

​    if (res == INF) res = -1;

​    return res;

  }

};
```



